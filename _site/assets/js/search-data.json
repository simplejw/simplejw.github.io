{"0": {
    "doc": "SpringBoot",
    "title": "安装 Spring Boot CLI",
    "content": "软件开发工具管理包(Software Development Kit Manager，SDKMAN，曾用简称GVM)也能用来安装和管理多版本Spring Boot CLI。使用前，你需要先从SDKMAN获取并安装SDKMAN。最简单的安装方式是使用命令行: . curl -s \"https://get.sdkman.io\" | bash source \"$HOME/.sdkman/bin/sdkman-init.sh\" . 一旦安装好了SDKMAN，就可以用下面的方式 来安装Spring Boot CLI了: . sdk install springboot // Spring Boot的当前版本号 spring --version // 使用SDKMAN的list命令可以找到可用的版本 sdk list springboot // 指定版本号安装 sdk install springboot 1.3.0.RELEASE // 切换到另一个版本 sdk use springboot 1.3.0.RELEASE // 默认版本，可以使用default命令 sdk default springboot 1.3.0.RELEASE . ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html#%E5%AE%89%E8%A3%85-spring-boot-cli",
    "relUrl": "/docs/java/SpringBoot.html#安装-spring-boot-cli"
  },"1": {
    "doc": "SpringBoot",
    "title": "使用 Spring Initializr 初始化 Spring Boot 项目",
    "content": "用浏览器打开start.spring.io . ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html#%E4%BD%BF%E7%94%A8-spring-initializr-%E5%88%9D%E5%A7%8B%E5%8C%96-spring-boot-%E9%A1%B9%E7%9B%AE",
    "relUrl": "/docs/java/SpringBoot.html#使用-spring-initializr-初始化-spring-boot-项目"
  },"2": {
    "doc": "SpringBoot",
    "title": "使用Profile进行配置",
    "content": ". | 如果你正在使用application.properties，可以创建额外的属性文件，遵循application-{profile}. properties这种命名格式，这样就能提供特定于Profile的属性了。 | . spring.profiles.active=production . | 使用多ProfileYAML文件进行配置:如果使用YAML来配置属性，则可以遵循与配置文件相同的命名规范，即创建application-{profile}.yml这样的YAML文件，并将与Profile无关的属性继续放在application.yml里。 | . spring: profiles: active: production . 但既然用了YAML，你就可以把所有Profile的配置属性都放在一个application.yml文件里。举例来说，我们可以像下面这样声明日志配置: . logging: level: root: INFO --- spring: profiles: development logging: level: root: DEBUG --- spring: profiles: production logging: path: /tmp/ file: BookWorm.log level: root: WARN . 如你所见，这个application.yml文件分为三个部分，使用一组三个连字符(—)作为分隔符。第二段和第三段分别为spring.profiles指定了一个值，这个值表示该部分配置应该应用在哪 个Profile里。第二段中定义的属性应用于开发环境，因为spring.profiles设置为development。与之类似，最后一段的spring.profile设置为production，在production Profile被激活时生效.另一方面，第一段并未指定spring.profiles，因此这里的属性对全部Profile都生效，或者对那些未设置该属性的激活Profile生效。 . ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html#%E4%BD%BF%E7%94%A8profile%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE",
    "relUrl": "/docs/java/SpringBoot.html#使用profile进行配置"
  },"3": {
    "doc": "SpringBoot",
    "title": "自定义 application.properties 里的变量",
    "content": ". | 配置类文件 | . // PropertiesConfig.java @Component @Data @ConfigurationProperties(prefix = \"my.properties\") public class PropertiesConfig { private String apiJWTKey; } . | 自定义变量 | . // application.properties my.properties.apiJWTKey=zOaXPmyWVTcQL3Y . | 使用变量 | . @Resource private PropertiesConfig propertiesConfig; propertiesConfig.getApiJWTKey(); . ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html#%E8%87%AA%E5%AE%9A%E4%B9%89-applicationproperties-%E9%87%8C%E7%9A%84%E5%8F%98%E9%87%8F",
    "relUrl": "/docs/java/SpringBoot.html#自定义-applicationproperties-里的变量"
  },"4": {
    "doc": "SpringBoot",
    "title": "配置自定义异常",
    "content": ". | 获取全局异常格式化出参 SpringExceptionHandler.java BusinessException.java | . @RestControllerAdvice @Slf4j public class SpringExceptionHandler { @ExceptionHandler(value = {AppException.class}) @ResponseStatus(HttpStatus.OK) @ResponseBody public BusinessException handleHttpException(HttpServletRequest req, AppException ex) { BusinessException businessException = new BusinessException(); businessException.setCode(ex.getCode()); businessException.setMsg(ex.getMsg()); businessException.setInfo(ex.getInfo()); log.info(\"URL:{} businessException:{}\", req.getRequestURI(), businessException); return businessException; } } . @Data @NoArgsConstructor @AllArgsConstructor public class BusinessException { private String code; private String msg; private Object info; } . | 自定义异常类 AppException.java | . @Data @EqualsAndHashCode(callSuper=false) public class AppException extends RuntimeException { private String code; private String msg; private Object info; public AppException(String code, String msg, Object info) { this.code = code; this.msg = msg; this.info = info; } public AppException(ErrorCodeDefine errorCodeDefine) { this.code = errorCodeDefine.getExternalCode(); this.msg = errorCodeDefine.getExternalMsg(); this.info = errorCodeDefine.getExternalInfo(); } } . | 自定义错误码 ErrorCodeDefine.java LoginException.java | . public interface ErrorCodeDefine { String getExternalCode(); String getExternalMsg(); Class&lt;?&gt; getExternalInfo(); } . public enum LoginException implements ErrorCodeDefine { WECHAT_CODE_SESSION(\"60001\", \"codeTwoSession error\", null); @Getter private String externalCode; @Getter private String externalMsg; @Getter private Class&lt;?&gt; externalInfo; LoginException(String externalCode, String externalMsg, Class&lt;?&gt; externalInfo) { this.externalCode = externalCode; this.externalMsg = externalMsg; this.externalInfo = externalInfo; } } . | 使用自定义枚举的异常 | . throw new AppException(LoginException.WECHAT_CODE_SESSION); . ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html#%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8",
    "relUrl": "/docs/java/SpringBoot.html#配置自定义异常"
  },"5": {
    "doc": "SpringBoot",
    "title": "SpringBoot",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/java/SpringBoot.html",
    "relUrl": "/docs/java/SpringBoot.html"
  },"6": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "http://0.0.0.0:4000/about/",
    "relUrl": "/about/"
  },"7": {
    "doc": "Base",
    "title": "遍历语句",
    "content": "// 遍历循环 int[] primes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; for(int n : primes) System.out.println(n); // for循环 for(int i = 0; i &lt; words.length; i++) { if (i &gt; 0) System.out.print(\", \"); System.out.print(words[i]); } . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E9%81%8D%E5%8E%86%E8%AF%AD%E5%8F%A5",
    "relUrl": "/docs/java/base.html#遍历语句"
  },"8": {
    "doc": "Base",
    "title": "try/catch/finally语句",
    "content": "try { // 正常情况下，这里的代码从上到下运行，没有问题 // 但是，有时可能抛出异常 // 可能是throw语句直接抛出 // 也可能是调用的方法间接抛出 } catch (SomeException e1) { // 这段代码中的语句用于处理SomeException或其子类类型的异常对象 // 在这段代码中，可以使用名称e1引用那个异常对象 } catch (AnotherException | YetAnotherException e2) { // 这段代码中的语句用于处理AnotherException、YetAnotherException // 或二者的子类类型的异常。在这段代码中，使用名称e2引用传入的异常对象 } finally { // 不管try子句的结束方式如何，这段代码中的语句都会执行： // 1）正常结束：到达块的末尾 // 2）由break、continue或return语句导致 // 3）抛出异常，由上述catch子句处理 // 4）抛出异常，未被捕获处理 // 但是，如果在try子句中调用了System.exit()，解释器会立即退出 // 不执行finally子句 } . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#trycatchfinally%E8%AF%AD%E5%8F%A5",
    "relUrl": "/docs/java/base.html#trycatchfinally语句"
  },"9": {
    "doc": "Base",
    "title": "定义类的句法",
    "content": "类声明可以包含修饰符关键字。除访问控制修饰符（public、protected 等）之外，还可以使用： . | abstract | . abstract 修饰的类未完全实现，不能实例化。只要类中有 abstract 修饰的方法，这个类就必须使用 abstract 声明。 . | final | . final 修饰符指明这个类无法被扩展。类不能同时声明为 abstract 和 final。 . | strictfp | . 如果类声明为 strictfp，那么其中所有的方法都声明为 strictfp。这个修饰符极少使用。 . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8F%A5%E6%B3%95",
    "relUrl": "/docs/java/base.html#定义类的句法"
  },"10": {
    "doc": "Base",
    "title": "类 static",
    "content": ". | 和类字段一样，类方法也使用 static 修饰符声明，类方法不能使用任何实例字段或实例方法，因为类方法不关联在类的实例身上。 | 实例方法处理类的具体实例（对象），只要声明方法时没使用 static 关键字，这个方法默认就是实例方法。实例方法没有这种限制，不管类中的成员有没有声明为 static，实例方法都可以使用。 | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E7%B1%BB-static",
    "relUrl": "/docs/java/base.html#类-static"
  },"11": {
    "doc": "Base",
    "title": "类 构造方法",
    "content": ". | 构造方法的名称始终和类名一样。 . | 声明构造方法时不指定返回值类型，连 void 都不用。 . | 构造方法的主体初始化对象。可以把主体的作用想象为设定 this 引用的内容。 . | 构造方法不能返回 this 或任何其他值。 . | 只要构造方法的参数列表不同，为一个类定义多个构造方法完全是合法的。编译器会根据提供的参数数量和类型判断你想使用的是哪个构造方法。定义多个构造方法和方法重载的原理类似。 . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E7%B1%BB-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95",
    "relUrl": "/docs/java/base.html#类-构造方法"
  },"12": {
    "doc": "Base",
    "title": "类 super",
    "content": ". | 使用 super() 调用构造方法和使用 this() 调用构造方法有同样的限制： . | 只能在构造方法中像这样使用 super()； . | 必须在构造方法的第一个语句中调用超类的构造方法，甚至要放在局部变量声明之前。 . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E7%B1%BB-super",
    "relUrl": "/docs/java/base.html#类-super"
  },"13": {
    "doc": "Base",
    "title": "访问控制和继承",
    "content": ". | 一个 Java 类只能继承一个类。 . | 子类继承超类中所有可以访问的实例字段和实例方法； . | 如果子类和超类在同一个包中定义，那么子类继承所有没使用 private 声明的实例字段和方法； . | 如果子类在其他包中定义，那么它继承所有使用 protected 和 public 声明的实例字段和方法； . | 使用 private 声明的字段和方法绝不会被继承；类字段和类方法也一样； . | 构造方法不会被继承。 . | 类继承超类的所有实例字段和实例方法（但不继承构造方法）； . | 在类的主体中始终可以访问这个类定义的所有字段和方法，而且还可以访问继承自超类的可访问的字段和方法。 . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF",
    "relUrl": "/docs/java/base.html#访问控制和继承"
  },"14": {
    "doc": "Base",
    "title": "定义接口",
    "content": ". | 接口中所有强制方法都隐式使用 abstract 声明，不能有方法主体，要使用分号。可以使用 abstract 修饰符，但一般习惯省略。 . | 接口定义公开的 API。接口中的所有成员都隐式使用 public 声明，而且习惯省略不必要的 public 修饰符。如果在接口中使用 protected 或 private 定义方法，会导致编译时错误。 . | 接口不能定义任何实例字段。字段是实现细节，而接口是规格不是实现。在接口中只能定义同时使用 static 和 final 声明的常量。 . | 接口不能实例化，因此不定义构造方法。 . | 接口中可以包含嵌套类型。嵌套类型隐式使用 public 和 static 声明。4.4 节会完整介绍嵌套类型。 . | . 从 Java 8 开始，接口中可以包含静态方法。Java 之前的版本不允许这么做，这被广泛认为是 Java 语言的一个设计缺陷。 . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3",
    "relUrl": "/docs/java/base.html#定义接口"
  },"15": {
    "doc": "Base",
    "title": "枚举",
    "content": ". | 不能泛型化； . | 可以实现接口； . | 不能被扩展； . | 如果枚举中的所有值都有实现主体，那么只能定义为抽象方法； . | 只能有一个私有（或使用默认访问权限）的构造方法。 . | 都（隐式）扩展 java.lang.Enum 类； . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E6%9E%9A%E4%B8%BE",
    "relUrl": "/docs/java/base.html#枚举"
  },"16": {
    "doc": "Base",
    "title": "lambda",
    "content": "(p, q) -&gt; { /* 方法主􏷮 */ } . | lambda 表达式必须出现在期望使用接口类型实例的地方； . | 期望使用的接口类型必须只有一个强制方法； . | 这个强制方法的签名要完全匹配 lambda 表达式。 . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#lambda",
    "relUrl": "/docs/java/base.html#lambda"
  },"17": {
    "doc": "Base",
    "title": "线程",
    "content": ". | NEW | . 已经创建线程，但还没在线程对象上调用 start() 方法。所有线程一开始都处于这个状态。 . | RUNNABLE | . 线程正在运行，或者当操作系统调度线程时可以运行。 . | BLOCKED | . 线程中止运行，因为它在等待获得一个锁，以便进入声明为 synchronized 的方法或代码块。本节后面会详细介绍声明为 synchronized 的方法和代码块。 . | WAITING | . 线程中止运行，因为它调用了 Object.wait() 或 Thread.join() 方法。 . | TIMED_WAITING | . 线程中止运行，因为它调用了 Thread.sleep() 方法，或者调用了 Object.wait() 或 Thread.join() 方法，而且传入了超时时间。 . | TERMINATED | . 线程执行完毕。线程对象的 run() 方法正常退出，或者抛出了异常。 . 线程的生命周期 . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E7%BA%BF%E7%A8%8B",
    "relUrl": "/docs/java/base.html#线程"
  },"18": {
    "doc": "Base",
    "title": "java 集合",
    "content": "集合类及其继承关系 . 实现Set接口的类 . 实现List接口的类 . 实现Map接口的类 . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#java-%E9%9B%86%E5%90%88",
    "relUrl": "/docs/java/base.html#java-集合"
  },"19": {
    "doc": "Base",
    "title": "函数式方式处理集合",
    "content": ". | 过滤器 这个模式把集合中的每个元素代入一段代码（返回 true 或 false），然后使用“通过测试”（即代入元素的那段代码返回 true）的元素构建一个新集合。 . String[] input = {\"tiger\", \"cat\", \"TIGER\", \"Tiger\", \"leopard\"}; List&lt;String&gt; cats = Arrays.asList(input); String search = \"tiger\"; String tigers = cats.stream() .filter(s -&gt; s.equalsIgnoreCase(search)) .collect(Collectors.joining(\", \")); System.out.println(tigers); . | 映射 映射模式把一种类型元素组成的集合转换成另一种类型元素组成的集合。 . String[] input = {\"tiger\", \"cat\", \"TIGER\", \"Tiger\", \"leopard\"}; List&lt;String&gt; cats = Arrays.asList(input); List&lt;Integer&gt; namesLength = cats.stream() .map(String::length) .collect(Collectors.toList()); System.out.println(namesLength); . | 遍历 在 Java 中经常需要处理可变的数据，所以新的集合 API 提供了一个方法，在遍历集合时修改元素——forEach() 方法。不是说 map() 或 filter() 方法一定不能修改元素。不要使用这两个方法修改元素，这只是一种约定，每个 Java 程序员都要遵守。 . List&lt;String&gt; pets = Arrays.asList(\"dog\", \"cat\", \"fish\", \"iguana\", \"ferret\"); pets.stream().forEach(s -&gt; System.out.println(s)); . | 化简 这个方法实现的是化简模式，包含一系列相关的类似运算，有时也称为合拢或聚合运算。 . double sumPrimes = ((double)Stream.of(2, 3, 5, 7, 11, 13, 17, 19, 23) .reduce(10, (x, y) -&gt; {return x + y;})); System.out.println(\"Sum of some primes: \" + sumPrimes); . | . ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E9%9B%86%E5%90%88",
    "relUrl": "/docs/java/base.html#函数式方式处理集合"
  },"20": {
    "doc": "Base",
    "title": "正则表达式",
    "content": ". ",
    "url": "http://0.0.0.0:4000/docs/java/base.html#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    "relUrl": "/docs/java/base.html#正则表达式"
  },"21": {
    "doc": "Base",
    "title": "Base",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/java/base.html",
    "relUrl": "/docs/java/base.html"
  },"22": {
    "doc": "Buttons",
    "title": "Buttons",
    "content": "Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-title.MARKUP . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: . def print_hi(name) puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk. ",
    "url": "http://0.0.0.0:4000/docs/component/buttons.html",
    "relUrl": "/docs/component/buttons.html"
  },"23": {
    "doc": "Code",
    "title": "Code",
    "content": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-title.MARKUP . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: . def print_hi(name) puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk. ",
    "url": "http://0.0.0.0:4000/docs/component/code.html",
    "relUrl": "/docs/component/code.html"
  },"24": {
    "doc": "Database",
    "title": "Docker 部署 Mysql Mongo",
    "content": ". | docker-compose.yml 文件 | . # Use root/example as user/password credentials version: '3.1' services: web_mysql: image: mysql:5.7 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci restart: always environment: MYSQL_ROOT_PASSWORD: example TZ: Asia/Shanghai command: mysqld --sql_mode=\"\" ports: - 3306:3306 volumes: - ./mysql/etc:/etc/mysql - ./mysql/conf.d:/etc/mysql/conf.d - ./mysql/data:/var/lib/mysql - ./mysql/log:/var/log/mysql networks: - net-database web_mongo: image: mongo:4.4 environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: example ports: - 27017:27017 volumes: - ./mongo/db:/data/db - ./mongo/log:/var/log/mongodb - ./mongo/etc:/etc/mongo networks: - net-database networks: # net-mysql: # net-mongo: net-database: . ",
    "url": "http://0.0.0.0:4000/docs/docker/database.html#docker-%E9%83%A8%E7%BD%B2-mysql-mongo",
    "relUrl": "/docs/docker/database.html#docker-部署-mysql-mongo"
  },"25": {
    "doc": "Database",
    "title": "Database",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/docker/database.html",
    "relUrl": "/docs/docker/database.html"
  },"26": {
    "doc": "Go",
    "title": "Go",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/golang/",
    "relUrl": "/docs/golang/"
  },"27": {
    "doc": "Git",
    "title": "Git",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/git/",
    "relUrl": "/docs/git/"
  },"28": {
    "doc": "Welcome to Jekyll",
    "title": "Welcome to Jekyll",
    "content": "You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-title.MARKUP . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: . def print_hi(name) puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk. ",
    "url": "http://0.0.0.0:4000/docs/component/",
    "relUrl": "/docs/component/"
  },"29": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/java/",
    "relUrl": "/docs/java/"
  },"30": {
    "doc": "Docker",
    "title": "Docker",
    "content": "进入容器 bash . docker-compose exec {service_name} bash . docker exec -it {container_id} bash . ",
    "url": "http://0.0.0.0:4000/docs/docker/",
    "relUrl": "/docs/docker/"
  },"31": {
    "doc": "Issue",
    "title": "GitHub 问题",
    "content": ". | git push失败 | . git@github.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. | 解决方案：link | . ",
    "url": "http://0.0.0.0:4000/docs/git/issue.html#github-%E9%97%AE%E9%A2%98",
    "relUrl": "/docs/git/issue.html#github-问题"
  },"32": {
    "doc": "Issue",
    "title": "Issue",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/git/issue.html",
    "relUrl": "/docs/git/issue.html"
  },"33": {
    "doc": "MyBatis",
    "title": "mybatis 生成代码工具",
    "content": ". | mybatis-generator-gui | . Mapper 接口类需要加 @Mapper 注解！！！ . XljMemberExample xljMemberExample = new XljMemberExample(); xljMemberExample.createCriteria().andOpenIdEqualTo(jsCode).andIsDelEqualTo(false); List&lt;XljMember&gt; memberList = xljMemberMapper.selectByExample(xljMemberExample); . ",
    "url": "http://0.0.0.0:4000/docs/java/mybatis.html#mybatis-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%B7%A5%E5%85%B7",
    "relUrl": "/docs/java/mybatis.html#mybatis-生成代码工具"
  },"34": {
    "doc": "MyBatis",
    "title": "获取自增ID",
    "content": "xml sql标签新增属性 . keyProperty=\"recordList.id\" useGeneratedKeys=\"true\" . 取的时候 . Long last_insert_id = someObject.getId(); . ",
    "url": "http://0.0.0.0:4000/docs/java/mybatis.html#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%A2%9Eid",
    "relUrl": "/docs/java/mybatis.html#获取自增id"
  },"35": {
    "doc": "MyBatis",
    "title": "MyBatis",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/java/mybatis.html",
    "relUrl": "/docs/java/mybatis.html"
  },"36": {
    "doc": "PHP",
    "title": "Docker 部署 PHP Nginx Radis",
    "content": ". | 目录结构 | . dnp ├── nginx │ └── certs/ │ └── conf/ │ └── log/ │ └── certs/ │ └── Dockerfile │ │ ├── php-fpm │ └── tmp/ │ └── php.ini │ └── www.conf │ └── Dockerfile │ │ ├── redis │ └── redis.conf │ └── Dockerfile │ │ ├── www/ │ │ └── docker-compose.yml . | docker-compose.yml 文件 | . version: '3' services: web_nginx: build: ./nginx ports: - \"80:80\" - \"443:443\" volumes: # source - ./www/:/usr/share/nginx/html/ - ./nginx/log/:/var/log/nginx/:rw - ./nginx/certs/:/etc/ssl/certs/:ro - ./nginx/conf/:/etc/nginx/conf.d/:ro networks: - frontend web_php_fpm: build: ./php-fpm expose: - \"9000\" - \"9003\" volumes: - ./php-fpm/php.ini:/usr/local/etc/php/php.ini:ro - ./php-fpm/www.conf:/usr/local/etc/php-fpm.d/www.conf:ro - ./php-fpm/tmp/:/tmp/ - ./www/:/usr/share/nginx/html/ networks: - frontend - backend web_redis: build: ./redis ports: - \"6379:6379\" volumes: # source - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro networks: - backend elasticsearch: image: elasticsearch:7.8.1 container_name: elasticsearch_781 environment: - node.name=es-node - cluster.name=es-cluster - discovery.type=single-node volumes: - ./elasticsearch/esdata:/usr/share/elasticsearch/data ports: - 9200:9200 - 9300:9300 networks: - frontend kibana: image: kibana:7.8.1 container_name: kibana_781 ports: - 5601:5601 networks: - frontend networks: frontend: backend: external: name: database_net-database . ",
    "url": "http://0.0.0.0:4000/docs/docker/php.html#docker-%E9%83%A8%E7%BD%B2-php-nginx-radis",
    "relUrl": "/docs/docker/php.html#docker-部署-php-nginx-radis"
  },"37": {
    "doc": "PHP",
    "title": "PHP",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/docker/php.html",
    "relUrl": "/docs/docker/php.html"
  },"38": {
    "doc": "Swagger",
    "title": "springboot + swagger",
    "content": "版本： . | gradle . | ‘org.springframework.boot’ version ‘2.5.8’ . | ‘io.springfox:springfox-boot-starter:3.0.0’ . | . 步骤： . | gradle 引入 springfox | . implementation 'io.springfox:springfox-boot-starter:3.0.0' . | 加swagger配置 | . package com.example.demo; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 @ConditionalOnProperty(name = \"swagger.enable\", havingValue = \"true\") public class SwaggerConfig { // controller package path 包路径 private static final String controllerPath = \"com.example.demo.controller\"; @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(controllerPath)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"Spring Boot + Swagger2 =&gt; RestFul API\") .contact(new Contact(\"Nemo\", \"www.baidu.com\", \"my@eamil.com\")) .version(\"1.0\") .description(\"API Desc\") .build(); } } . | application.properties 配置 | . #是否激活 swagger true or false swagger.enable=true . | 效果 | . http://localhost:8080/swagger-ui/index.html . ",
    "url": "http://0.0.0.0:4000/docs/java/swagger.html#springboot--swagger",
    "relUrl": "/docs/java/swagger.html#springboot--swagger"
  },"39": {
    "doc": "Swagger",
    "title": "Swagger",
    "content": " ",
    "url": "http://0.0.0.0:4000/docs/java/swagger.html",
    "relUrl": "/docs/java/swagger.html"
  }
}
